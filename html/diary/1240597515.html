<h4>Fri Apr 24 2009 - New Object Model</h4>
<h5>- Dave Goehrig</h5>
<p>The past two days, I've been working on to major project changes to the beta:</p>
<ul>
<li>New welcome screen, channel, and user support</li>
<li>New javascript object model</li>
</ul>
<p>The new welcome screen will have support for logging into a user account and a channel.  Icon selection is now configurable by clicking on a user icon.  I've not completed the new registration code, but I'm planning on adding an addition to the website so that you can sign up to create an account and register a new channel.  I've decided for security reasons to remove all actual account tracking from within the app itself, as exposing that data in the app simply exposes it to all users. Here's a sneak peak at the new interface:</p>
<img src="/images/Welcome.png" width="490px" />
<p>The major rewrite under the hood has come about from writing Javascript as if its object model were that of the NewScript object model.  Rather than using the built in .prototype system, it is now using an <i>ad-hoc prototype</i> based system based on deep copying of prototype objects.  The primary advantage of this approach is that objects behave entirely as <i>traits</i> or <i>mix-ins</i>, and the .prototype chain has been flattened.  Additionally, a new low level function has been added to handle <i>ad-hoc classiness</i>.</p>
<pre>
Object.prototype.isa = function(x) {
        var retval = true;
        x.each(function(v,k) {
                if (!this.hasOwnProperty(k))
                        return retval = false;
        });
        return retval;
}
</pre>
<p>Basically, how this works is any Object can be considered a <i>class</i> in the NewScript sense of the word.  An object which implements all of the methods of a given <i>class</i> is said to be a member of that class.This allows two object which share absolutely no prototypes in common to be members of the same <i>class</i>, as they exhibit the same basic semantics, rather than a shared implementation.  
</p>
<p>The primary reason for redoing the object models was initially to make it possible to write elements of the interface in NewScript.  One of the major reasons for doing this deep-copy technique is that it mimics NewScript object creation.  It trades off fewer object instances for more slots per object.  While we don't gain some of the memory efficiency of the native prototype system, we gain the ability to merge object easily at runtime.  It also makes <i>ad-hoc classiness</i> easier to implement and maintain, the prototype tree is flat.</p>
<h4>Future Development</h4>
<p>One of the major changes to the design that will make it into the interface this weekend is I'm ditching the concept of cut/paste, and add/remove slots.  I've realized that both of those are a messy anachronism that come out of interfaces that aren't nearly as directly manipulable as this one.  So I'm reducing it to two concepts:</p>
<dl>
<dt>strike</dt><dd>draw a red line through some element to strike it out / remove it</dd>
<dt>merge</dd><dd>draw a green line between two elements to merge them into a single element</dd>
</dl>
<p>This converts the 4 modes of operations to 2 operations, and has the added advantage that they'll work nicely on a touch screen.  Rather than having some nebulous "clipboard" that contains off screen state, which when you think about it is a pretty stupid idea, these operations work entirely upon visible elements.  If you want to add some new features to an existing object, just create a new set of definitions near it, and connect them with a green line... <i>poof</i>... the target object acquires the new features!  Don't think you need some methods any more... strike them out with a red line.. <i>poof</i>... they're gone!  </p>
<p>Since all of the objects are persistent, undo takes on a new concept as well.  Once the object history browser is finished, there'll be little need for "undo" that nebulous concept of returning to a previous state.  Rather than having to worry about backtracking, you can just as well load the older version.  I might even add a quick "diff" gesture, to display the changes between two versions of the object, to make merging changes easy.  Something like draw a blue line between two versions, and it kicks out the changed definitions like billard balls after a break.  Then you can merge the changes you want into whatever object.
</p>

